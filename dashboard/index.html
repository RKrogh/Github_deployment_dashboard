<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Deploy Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --bg-primary: #0d1117;
      --bg-secondary: #161b22;
      --bg-tertiary: #21262d;
      --border: #30363d;
      --text-primary: #e6edf3;
      --text-secondary: #8b949e;
      --text-link: #58a6ff;
      --green: #3fb950;
      --red: #f85149;
      --yellow: #d29922;
      --orange: #db6d28;
      --blue: #58a6ff;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      line-height: 1.5;
      min-height: 100vh;
    }

    .setup-panel {
      max-width: 540px;
      margin: 80px auto;
      padding: 32px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 12px;
    }
    .setup-panel h1 { font-size: 24px; margin-bottom: 24px; font-weight: 600; }
    .form-group { margin-bottom: 20px; }
    .form-group label {
      display: block; font-size: 14px; font-weight: 500;
      margin-bottom: 6px; color: var(--text-primary);
    }
    .form-group small { display: block; font-size: 12px; color: var(--text-secondary); margin-top: 4px; }
    input[type="text"], input[type="password"], input[type="url"], textarea, select {
      width: 100%; padding: 8px 12px; font-size: 14px;
      background: var(--bg-primary); border: 1px solid var(--border);
      border-radius: 6px; color: var(--text-primary); font-family: inherit;
    }
    input:focus, textarea:focus, select:focus {
      outline: none; border-color: var(--blue);
      box-shadow: 0 0 0 2px rgba(88, 166, 255, 0.3);
    }
    textarea { resize: vertical; }

    .tab-group {
      display: flex; gap: 0; margin-bottom: 8px;
      border: 1px solid var(--border); border-radius: 6px; overflow: hidden;
    }
    .tab {
      flex: 1; padding: 6px 12px; font-size: 13px;
      background: var(--bg-tertiary); color: var(--text-secondary);
      border: none; cursor: pointer; font-family: inherit;
    }
    .tab.active { background: var(--blue); color: #fff; }

    .btn-primary {
      display: inline-block; padding: 8px 20px; font-size: 14px; font-weight: 500;
      background: #238636; color: #fff;
      border: 1px solid rgba(240, 246, 252, 0.1); border-radius: 6px;
      cursor: pointer; font-family: inherit;
    }
    .btn-primary:hover { background: #2ea043; }
    .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }

    .btn-secondary {
      display: inline-block; padding: 6px 14px; font-size: 13px;
      background: var(--bg-tertiary); color: var(--text-primary);
      border: 1px solid var(--border); border-radius: 6px;
      cursor: pointer; font-family: inherit;
    }
    .btn-secondary:hover { background: var(--border); }

    .error-msg {
      margin-top: 12px; padding: 10px 14px;
      background: rgba(248, 81, 73, 0.1); border: 1px solid rgba(248, 81, 73, 0.4);
      border-radius: 6px; color: var(--red); font-size: 13px;
    }

    .mode-badge {
      display: inline-block; font-size: 11px; font-weight: 500;
      padding: 2px 8px; border-radius: 10px; margin-left: 10px; vertical-align: middle;
    }
    .mode-badge--static { background: rgba(63, 185, 80, 0.15); color: var(--green); }
    .mode-badge--api { background: rgba(88, 166, 255, 0.15); color: var(--blue); }

    .hidden { display: none !important; }

    .dashboard { max-width: 1400px; margin: 0 auto; padding: 20px 24px; }
    .dashboard header {
      display: flex; justify-content: space-between; align-items: center;
      flex-wrap: wrap; gap: 12px; margin-bottom: 20px;
      padding-bottom: 16px; border-bottom: 1px solid var(--border);
    }
    .dashboard header h1 { font-size: 20px; font-weight: 600; }
    .controls { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
    .controls input[type="text"] { width: 200px; }
    .controls select { width: auto; }
    .refresh-info { font-size: 12px; color: var(--text-secondary); min-width: 60px; text-align: right; }

    .table-container {
      overflow-x: auto; border: 1px solid var(--border); border-radius: 8px;
    }
    table { width: 100%; border-collapse: collapse; font-size: 14px; }
    thead th {
      position: sticky; top: 0; background: var(--bg-tertiary);
      padding: 10px 16px; text-align: left; font-weight: 600;
      font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px;
      color: var(--text-secondary); border-bottom: 1px solid var(--border); white-space: nowrap;
    }
    tbody tr { border-bottom: 1px solid var(--border); }
    tbody tr:last-child { border-bottom: none; }
    tbody tr:hover { background: rgba(136, 149, 167, 0.04); }
    td { padding: 10px 16px; vertical-align: middle; white-space: nowrap; }
    td.service-name { font-weight: 500; min-width: 160px; }
    td.service-name .mono-label {
      display: block; font-size: 11px; color: var(--text-secondary); font-weight: 400;
    }

    .cell { min-width: 140px; }
    .cell a {
      color: var(--text-link); text-decoration: none;
      font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
      font-size: 13px;
    }
    .cell a:hover { text-decoration: underline; }
    .cell .time { display: block; font-size: 11px; color: var(--text-secondary); margin-top: 2px; }
    .cell .status-dot {
      display: inline-block; width: 8px; height: 8px; border-radius: 50%;
      margin-right: 6px; vertical-align: middle;
    }
    .status-success { background: var(--green); }
    .status-failure, .status-error { background: var(--red); }
    .status-pending, .status-queued, .status-in_progress { background: var(--yellow); }
    .status-inactive { background: var(--text-secondary); }
    .status-unknown { background: var(--border); }
    .cell--empty { color: var(--text-secondary); font-size: 13px; }
    .cell .env-link {
      display: inline-block; margin-left: 4px; color: var(--text-secondary);
      text-decoration: none; font-size: 11px; vertical-align: middle;
    }
    .cell .env-link:hover { color: var(--text-link); }

    tr.drift { background: rgba(219, 109, 40, 0.06); }
    tr.drift td:first-child { border-left: 3px solid var(--orange); }
    .drift-badge {
      display: inline-block; font-size: 10px; font-weight: 600;
      text-transform: uppercase; letter-spacing: 0.5px; color: var(--orange);
      background: rgba(219, 109, 40, 0.15); padding: 1px 6px;
      border-radius: 10px; margin-left: 8px; vertical-align: middle;
    }

    .skeleton {
      background: linear-gradient(90deg, var(--bg-tertiary) 25%, var(--border) 50%, var(--bg-tertiary) 75%);
      background-size: 200% 100%; animation: shimmer 1.5s infinite;
      border-radius: 4px; height: 14px; margin-bottom: 4px;
    }
    .skeleton--sha { width: 70px; }
    .skeleton--time { width: 50px; height: 10px; }
    @keyframes shimmer { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }

    .error-banner {
      margin-top: 12px; padding: 10px 14px;
      background: rgba(248, 81, 73, 0.1); border: 1px solid rgba(248, 81, 73, 0.4);
      border-radius: 6px; color: var(--red); font-size: 13px;
    }
    .error-banner .dismiss {
      float: right; cursor: pointer; color: var(--text-secondary);
      font-size: 16px; line-height: 1; border: none; background: none;
    }

    .summary-bar {
      display: flex; gap: 16px; margin-bottom: 16px; padding: 10px 16px;
      background: var(--bg-secondary); border: 1px solid var(--border);
      border-radius: 8px; font-size: 13px; color: var(--text-secondary);
    }
    .summary-bar .stat { display: flex; align-items: center; gap: 6px; }
    .summary-bar .stat-value { font-weight: 600; color: var(--text-primary); }
    .summary-bar .stat-value--drift { color: var(--orange); }
    .summary-bar .stat-value--ok { color: var(--green); }

    .empty-state { text-align: center; padding: 60px 20px; color: var(--text-secondary); }
    .empty-state h2 { font-size: 18px; margin-bottom: 8px; color: var(--text-primary); }
  </style>
</head>
<body>
<div id="app">
  <!-- Setup Panel -->
  <div id="setup" class="setup-panel">
    <h1>Deploy Dashboard</h1>

    <div id="mode-section" class="form-group">
      <label>Data Source</label>
      <div class="tab-group">
        <button class="tab active" id="mode-static">Static Files</button>
        <button class="tab" id="mode-api">GitHub API</button>
      </div>
      <small id="mode-hint">Static mode reads status files pushed by the deploy action. No token needed.</small>
    </div>

    <div id="token-group" class="form-group hidden">
      <label for="token-input">GitHub Token (PAT)</label>
      <input type="password" id="token-input" placeholder="ghp_...">
      <small>Stored in localStorage. Needs <code>repo</code> scope or fine-grained <code>deployments:read</code> on target repos.</small>
    </div>

    <div class="form-group">
      <label>Configuration</label>
      <div class="tab-group">
        <button class="tab active" data-tab="url" id="tab-url">URL</button>
        <button class="tab" data-tab="paste" id="tab-paste">Paste YAML</button>
        <button class="tab" data-tab="auto" id="tab-auto">Auto-detect</button>
      </div>
      <input type="url" id="config-url" class="hidden" placeholder="https://raw.githubusercontent.com/org/repo/main/.deploy-dashboard.yml">
      <textarea id="config-yaml" class="hidden" rows="12" placeholder="org: your-org&#10;environments:&#10;  - dev&#10;  - staging&#10;  - prod&#10;services:&#10;  - repo: my-service"></textarea>
      <small id="auto-hint" class="">Looks for .deploy-dashboard.yml next to this page.</small>
    </div>

    <div class="form-group">
      <label for="refresh-input">Refresh interval (seconds)</label>
      <input type="text" id="refresh-input" value="30" style="width:80px">
    </div>

    <button id="btn-load" class="btn-primary">Load Dashboard</button>
    <div id="setup-error" class="error-msg hidden"></div>
  </div>

  <!-- Dashboard -->
  <div id="dashboard" class="dashboard hidden">
    <header>
      <h1>Deploy Dashboard &mdash; <span id="org-name"></span>
        <span id="mode-indicator" class="mode-badge"></span>
      </h1>
      <div class="controls">
        <input type="text" id="filter-input" placeholder="Filter services...">
        <select id="sort-select">
          <option value="config">Config order</option>
          <option value="name">Name (A-Z)</option>
          <option value="drift">Drift first</option>
        </select>
        <span id="refresh-countdown" class="refresh-info"></span>
        <button id="btn-refresh" class="btn-secondary">Refresh</button>
        <button id="btn-settings" class="btn-secondary">Settings</button>
      </div>
    </header>
    <div id="summary-bar" class="summary-bar hidden"></div>
    <div id="table-container"></div>
    <div id="error-container"></div>
  </div>
</div>

<script>
(function () {
  'use strict';

  // ============================================================
  // STATE
  // ============================================================
  const state = {
    dataMode: localStorage.getItem('ghdd-data-mode') || 'static', // 'static' or 'api'
    token: localStorage.getItem('ghdd-token') || '',
    configTab: localStorage.getItem('ghdd-config-tab') || 'auto', // 'url', 'paste', 'auto'
    configUrl: localStorage.getItem('ghdd-config-url') || '',
    configYaml: localStorage.getItem('ghdd-config-yaml') || '',
    refreshInterval: parseInt(localStorage.getItem('ghdd-refresh-interval') || '30', 10),
    config: null,
    deployments: new Map(),
    driftDetails: new Map(),
    loading: false,
    errors: [],
    filterText: '',
    sortMode: 'config',
    countdownSeconds: 0,
    refreshTimer: null,
  };

  // ============================================================
  // DOM REFS
  // ============================================================
  const $ = (sel) => document.querySelector(sel);
  const setupEl = $('#setup');
  const dashboardEl = $('#dashboard');
  const modeStatic = $('#mode-static');
  const modeApi = $('#mode-api');
  const modeHint = $('#mode-hint');
  const tokenGroup = $('#token-group');
  const tokenInput = $('#token-input');
  const tabUrl = $('#tab-url');
  const tabPaste = $('#tab-paste');
  const tabAuto = $('#tab-auto');
  const configUrlInput = $('#config-url');
  const configYamlInput = $('#config-yaml');
  const autoHint = $('#auto-hint');
  const refreshInput = $('#refresh-input');
  const btnLoad = $('#btn-load');
  const setupError = $('#setup-error');
  const orgName = $('#org-name');
  const modeIndicator = $('#mode-indicator');
  const filterInput = $('#filter-input');
  const sortSelect = $('#sort-select');
  const refreshCountdown = $('#refresh-countdown');
  const btnRefresh = $('#btn-refresh');
  const btnSettings = $('#btn-settings');
  const summaryBar = $('#summary-bar');
  const tableContainer = $('#table-container');
  const errorContainer = $('#error-container');

  // ============================================================
  // CONFIG PARSER
  // ============================================================
  function parseConfig(yamlText) {
    const raw = jsyaml.load(yamlText);
    if (!raw || !raw.org || !raw.environments || !raw.services) {
      throw new Error('Config must include org, environments, and services.');
    }

    const config = {
      org: raw.org,
      environments: raw.environments,
      services: [],
    };

    for (const entry of raw.services) {
      if (!entry.repo) {
        throw new Error('Each service entry must have a "repo" field.');
      }

      if (entry.services && Array.isArray(entry.services)) {
        for (const sub of entry.services) {
          config.services.push({
            key: entry.repo + '/' + sub.name,
            displayName: sub.display_name || sub.name,
            repo: entry.repo,
            owner: raw.org,
            monoRepoService: sub.name,
          });
        }
      } else {
        config.services.push({
          key: entry.repo,
          displayName: entry.display_name || entry.repo,
          repo: entry.repo,
          owner: raw.org,
          monoRepoService: null,
        });
      }
    }

    return config;
  }

  // ============================================================
  // STATIC FILE FETCHER
  // ============================================================
  async function fetchAllDeploymentsStatic(config) {
    const results = new Map();
    const errors = [];

    const fetches = [];
    for (const service of config.services) {
      const serviceName = service.monoRepoService || service.repo;
      for (const env of config.environments) {
        fetches.push({ service, env, serviceName });
      }
    }

    const settled = await Promise.allSettled(
      fetches.map(async ({ service, env, serviceName }) => {
        const url = 'status/' + encodeURIComponent(serviceName) + '/' + encodeURIComponent(env) + '.json';
        const resp = await fetch(url);
        if (resp.status === 404) return { key: service.key, env, data: null };
        if (!resp.ok) throw new Error(service.key + '/' + env + ': HTTP ' + resp.status);
        const data = await resp.json();
        return {
          key: service.key,
          env,
          data: {
            id: null,
            sha: data.sha,
            ref: data.ref,
            environment: data.environment || env,
            createdAt: data.timestamp,
            status: data.status || 'unknown',
            environmentUrl: data.environment_url || null,
            description: data.description || null,
            version: data.version || null,
            repoOwner: data.owner || service.owner,
            repoName: data.repo || service.repo,
          },
        };
      })
    );

    for (const result of settled) {
      if (result.status === 'fulfilled' && result.value.data) {
        const { key, env, data } = result.value;
        if (!results.has(key)) results.set(key, new Map());
        results.get(key).set(env, data);
      } else if (result.status === 'rejected') {
        errors.push(result.reason.message || 'Unknown fetch error');
      }
    }

    return { results, errors };
  }

  // ============================================================
  // GITHUB API FETCHER
  // ============================================================
  async function apiFetch(url, token) {
    const resp = await fetch(url, {
      headers: {
        Authorization: 'token ' + token,
        Accept: 'application/vnd.github+json',
      },
    });
    if (!resp.ok) {
      const body = await resp.text().catch(() => '');
      throw new Error('GitHub API ' + resp.status + ': ' + (body.slice(0, 200) || resp.statusText));
    }
    return resp.json();
  }

  async function fetchDeploymentForService(token, service, environment) {
    const perPage = service.monoRepoService ? 30 : 5;
    const url =
      'https://api.github.com/repos/' +
      encodeURIComponent(service.owner) + '/' +
      encodeURIComponent(service.repo) +
      '/deployments?environment=' + encodeURIComponent(environment) +
      '&per_page=' + perPage;

    let deployments;
    try {
      deployments = await apiFetch(url, token);
    } catch (err) {
      throw new Error(service.key + '/' + environment + ': ' + err.message);
    }

    let deployment = null;
    for (const d of deployments) {
      if (service.monoRepoService) {
        try {
          const payload = typeof d.payload === 'string' ? JSON.parse(d.payload) : d.payload;
          if (payload && payload.service === service.monoRepoService) {
            deployment = d;
            break;
          }
        } catch (_) { continue; }
      } else {
        deployment = d;
        break;
      }
    }

    if (!deployment) return null;

    let statusState = 'unknown';
    let envUrl = null;
    let statusDesc = deployment.description;
    try {
      const statusUrl =
        'https://api.github.com/repos/' +
        encodeURIComponent(service.owner) + '/' +
        encodeURIComponent(service.repo) +
        '/deployments/' + deployment.id + '/statuses?per_page=1';
      const statuses = await apiFetch(statusUrl, token);
      if (statuses.length > 0) {
        statusState = statuses[0].state;
        envUrl = statuses[0].environment_url || null;
        statusDesc = statuses[0].description || statusDesc;
      }
    } catch (_) {}

    let version = null;
    try {
      const payload = typeof deployment.payload === 'string'
        ? JSON.parse(deployment.payload) : deployment.payload;
      if (payload && payload.version) version = payload.version;
    } catch (_) {}

    return {
      id: deployment.id,
      sha: deployment.sha,
      ref: deployment.ref,
      environment: deployment.environment,
      createdAt: deployment.created_at,
      status: statusState,
      environmentUrl: envUrl,
      description: statusDesc,
      version: version,
      repoOwner: service.owner,
      repoName: service.repo,
    };
  }

  async function fetchAllDeploymentsApi(token, config) {
    const tasks = [];
    for (const service of config.services) {
      for (const env of config.environments) {
        tasks.push({ service, env });
      }
    }

    const results = new Map();
    const errors = [];
    const CONCURRENCY = 6;

    for (let i = 0; i < tasks.length; i += CONCURRENCY) {
      const batch = tasks.slice(i, i + CONCURRENCY);
      const settled = await Promise.allSettled(
        batch.map(({ service, env }) =>
          fetchDeploymentForService(token, service, env).then((data) => ({
            key: service.key, env, data,
          }))
        )
      );

      for (const result of settled) {
        if (result.status === 'fulfilled' && result.value.data) {
          const { key, env, data } = result.value;
          if (!results.has(key)) results.set(key, new Map());
          results.get(key).set(env, data);
        } else if (result.status === 'rejected') {
          errors.push(result.reason.message || 'Unknown fetch error');
        }
      }
    }

    return { results, errors };
  }

  // ============================================================
  // DRIFT DETAILS (commit distance via compare API â€” API mode only)
  // ============================================================
  async function fetchDriftDetails(token, config, deployments) {
    if (!token) return new Map();

    const details = new Map();
    const tasks = [];

    for (const service of config.services) {
      const deps = deployments.get(service.key);
      if (!deps || deps.size < 2) continue;

      let firstDep = null;
      let lastDep = null;
      for (const env of config.environments) {
        const dep = deps.get(env);
        if (dep && dep.status === 'success') {
          if (!firstDep) firstDep = dep;
          lastDep = dep;
        }
      }

      if (!firstDep || !lastDep || firstDep.sha === lastDep.sha) continue;

      tasks.push({
        key: service.key, owner: service.owner, repo: service.repo,
        baseSha: lastDep.sha, headSha: firstDep.sha,
      });
    }

    const CONCURRENCY = 6;
    for (let i = 0; i < tasks.length; i += CONCURRENCY) {
      const batch = tasks.slice(i, i + CONCURRENCY);
      const settled = await Promise.allSettled(
        batch.map(async (task) => {
          const url =
            'https://api.github.com/repos/' +
            encodeURIComponent(task.owner) + '/' +
            encodeURIComponent(task.repo) +
            '/compare/' + task.baseSha + '...' + task.headSha;
          const data = await apiFetch(url, token);
          return { key: task.key, aheadBy: data.ahead_by || 0, behindBy: data.behind_by || 0 };
        })
      );

      for (const result of settled) {
        if (result.status === 'fulfilled') {
          details.set(result.value.key, {
            aheadBy: result.value.aheadBy,
            behindBy: result.value.behindBy,
          });
        }
      }
    }

    return details;
  }

  // ============================================================
  // DRIFT DETECTION
  // ============================================================
  function detectDrift(serviceDeployments, environments) {
    if (!serviceDeployments || serviceDeployments.size < 2) return { hasDrift: false };

    let firstSha = null, lastSha = null, firstEnv = null, lastEnv = null;

    for (const env of environments) {
      const dep = serviceDeployments.get(env);
      if (dep && dep.status === 'success') {
        if (firstSha === null) { firstSha = dep.sha; firstEnv = env; }
        lastSha = dep.sha; lastEnv = env;
      }
    }

    if (!firstSha || !lastSha || firstEnv === lastEnv) return { hasDrift: false };

    return {
      hasDrift: firstSha !== lastSha,
      firstEnv, lastEnv,
      firstSha: firstSha.substring(0, 7),
      lastSha: lastSha.substring(0, 7),
    };
  }

  // ============================================================
  // RENDERING
  // ============================================================
  function relativeTime(isoString) {
    const diff = Date.now() - new Date(isoString).getTime();
    const seconds = Math.floor(diff / 1000);
    if (seconds < 60) return 'just now';
    const minutes = Math.floor(seconds / 60);
    if (minutes < 60) return minutes + 'm ago';
    const hours = Math.floor(minutes / 60);
    if (hours < 24) return hours + 'h ago';
    const days = Math.floor(hours / 24);
    if (days < 30) return days + 'd ago';
    return new Date(isoString).toLocaleDateString();
  }

  function escapeHtml(str) {
    const d = document.createElement('div');
    d.textContent = str;
    return d.innerHTML;
  }

  function renderSummary(config, deployments) {
    const total = config.services.length;
    let driftCount = 0, failCount = 0;

    for (const service of config.services) {
      const deps = deployments.get(service.key);
      const drift = detectDrift(deps, config.environments);
      if (drift.hasDrift) driftCount++;
      if (deps) {
        for (const [, dep] of deps) {
          if (dep.status === 'failure' || dep.status === 'error') { failCount++; break; }
        }
      }
    }

    if (total === 0) { summaryBar.classList.add('hidden'); return; }

    const okCount = total - driftCount;
    let html = '<span class="stat"><span class="stat-value">' + total + '</span> services</span>';
    if (driftCount > 0) {
      html += '<span class="stat"><span class="stat-value stat-value--drift">' + driftCount + '</span> drifted</span>';
    }
    html += '<span class="stat"><span class="stat-value stat-value--ok">' + okCount + '</span> in sync</span>';
    if (failCount > 0) {
      html += '<span class="stat"><span class="stat-value" style="color:var(--red)">' + failCount + '</span> with failures</span>';
    }

    summaryBar.innerHTML = html;
    summaryBar.classList.remove('hidden');
  }

  function renderTable(config, deployments) {
    let services = [...config.services];

    if (state.filterText) {
      const q = state.filterText.toLowerCase();
      services = services.filter(
        (s) => s.displayName.toLowerCase().includes(q) || s.key.toLowerCase().includes(q)
      );
    }

    const driftMap = new Map();
    for (const s of services) {
      driftMap.set(s.key, detectDrift(deployments.get(s.key), config.environments));
    }

    if (state.sortMode === 'name') {
      services.sort((a, b) => a.displayName.localeCompare(b.displayName));
    } else if (state.sortMode === 'drift') {
      services.sort((a, b) => {
        const da = driftMap.get(a.key).hasDrift ? 0 : 1;
        const db = driftMap.get(b.key).hasDrift ? 0 : 1;
        return da - db || a.displayName.localeCompare(b.displayName);
      });
    }

    if (services.length === 0) {
      tableContainer.innerHTML =
        '<div class="empty-state"><h2>No services found</h2><p>Check your config or filter.</p></div>';
      return;
    }

    let html = '<div class="table-container"><table><thead><tr><th>Service</th>';
    for (const env of config.environments) {
      html += '<th>' + escapeHtml(env) + '</th>';
    }
    html += '</tr></thead><tbody>';

    for (const service of services) {
      const drift = driftMap.get(service.key);
      html += '<tr' + (drift.hasDrift ? ' class="drift"' : '') + '>';

      html += '<td class="service-name">';
      html += escapeHtml(service.displayName);
      if (drift.hasDrift) {
        const dd = state.driftDetails.get(service.key);
        const label = dd && dd.aheadBy > 0 ? 'drift +' + dd.aheadBy : 'drift';
        const title = dd && dd.aheadBy > 0
          ? dd.aheadBy + ' commit' + (dd.aheadBy === 1 ? '' : 's') + ' in ' + drift.firstEnv + ' not in ' + drift.lastEnv
          : drift.firstEnv + ' and ' + drift.lastEnv + ' have different commits';
        html += '<span class="drift-badge" title="' + escapeHtml(title) + '">' + escapeHtml(label) + '</span>';
      }
      if (service.monoRepoService) {
        html += '<span class="mono-label">' + escapeHtml(service.repo) + '</span>';
      }
      html += '</td>';

      for (const env of config.environments) {
        const deps = deployments.get(service.key);
        const dep = deps ? deps.get(env) : null;

        if (state.loading && !dep) {
          html += '<td class="cell"><div class="skeleton skeleton--sha"></div><div class="skeleton skeleton--time"></div></td>';
        } else if (dep) {
          const shortSha = dep.sha.substring(0, 7);
          const commitUrl = 'https://github.com/' + dep.repoOwner + '/' + dep.repoName + '/commit/' + dep.sha;
          const displayVersion = dep.version && dep.version !== shortSha ? dep.version : null;

          html += '<td class="cell">';
          html += '<span class="status-dot status-' + dep.status + '"></span>';
          html += '<a href="' + commitUrl + '" target="_blank" rel="noopener" title="' + dep.sha + '">';
          html += displayVersion ? escapeHtml(displayVersion) : shortSha;
          html += '</a>';
          if (dep.environmentUrl) {
            html += '<a href="' + escapeHtml(dep.environmentUrl) + '" target="_blank" rel="noopener" class="env-link" title="Open environment">&#x2197;</a>';
          }
          html += '<span class="time" title="' + dep.createdAt + '">' + relativeTime(dep.createdAt) + '</span>';
          html += '</td>';
        } else {
          html += '<td class="cell cell--empty">&mdash;</td>';
        }
      }

      html += '</tr>';
    }

    html += '</tbody></table></div>';
    tableContainer.innerHTML = html;
  }

  function renderErrors(errors) {
    if (!errors.length) { errorContainer.innerHTML = ''; return; }
    const unique = [...new Set(errors)].slice(0, 5);
    let html = '';
    for (const msg of unique) {
      html +=
        '<div class="error-banner">' +
        '<button class="dismiss" onclick="this.parentElement.remove()">&times;</button>' +
        escapeHtml(msg) + '</div>';
    }
    errorContainer.innerHTML = html;
  }

  // ============================================================
  // CONTROLLER
  // ============================================================
  function updateSetupUI() {
    // Data mode
    if (state.dataMode === 'static') {
      modeStatic.classList.add('active');
      modeApi.classList.remove('active');
      tokenGroup.classList.add('hidden');
      modeHint.textContent = 'Static mode reads status files pushed by the deploy action. No token needed.';
    } else {
      modeApi.classList.add('active');
      modeStatic.classList.remove('active');
      tokenGroup.classList.remove('hidden');
      modeHint.textContent = 'API mode queries the GitHub Deployments API directly. Requires a token.';
    }

    // Config tab
    tabUrl.classList.remove('active');
    tabPaste.classList.remove('active');
    tabAuto.classList.remove('active');
    configUrlInput.classList.add('hidden');
    configYamlInput.classList.add('hidden');
    autoHint.classList.add('hidden');

    if (state.configTab === 'url') {
      tabUrl.classList.add('active');
      configUrlInput.classList.remove('hidden');
    } else if (state.configTab === 'paste') {
      tabPaste.classList.add('active');
      configYamlInput.classList.remove('hidden');
    } else {
      tabAuto.classList.add('active');
      autoHint.classList.remove('hidden');
    }
  }

  function showSetup() {
    setupEl.classList.remove('hidden');
    dashboardEl.classList.add('hidden');
    stopAutoRefresh();

    tokenInput.value = state.token;
    configUrlInput.value = state.configUrl;
    configYamlInput.value = state.configYaml;
    refreshInput.value = state.refreshInterval;
    updateSetupUI();
  }

  function showDashboard() {
    setupEl.classList.add('hidden');
    dashboardEl.classList.remove('hidden');

    if (state.dataMode === 'static') {
      modeIndicator.textContent = 'static';
      modeIndicator.className = 'mode-badge mode-badge--static';
    } else {
      modeIndicator.textContent = 'api';
      modeIndicator.className = 'mode-badge mode-badge--api';
    }
  }

  async function resolveConfig() {
    if (state.configTab === 'url') {
      const url = configUrlInput.value.trim();
      if (!url) throw new Error('Please enter a config URL.');
      const resp = await fetch(url);
      if (!resp.ok) throw new Error('Failed to fetch config: HTTP ' + resp.status);
      return resp.text();
    } else if (state.configTab === 'paste') {
      const yaml = configYamlInput.value.trim();
      if (!yaml) throw new Error('Please paste your YAML config.');
      return yaml;
    } else {
      // Auto-detect: try .deploy-dashboard.yml next to this page
      const resp = await fetch('.deploy-dashboard.yml');
      if (!resp.ok) throw new Error('No .deploy-dashboard.yml found next to this page. Use URL or Paste instead.');
      return resp.text();
    }
  }

  async function loadConfig() {
    state.token = tokenInput.value.trim();
    state.configUrl = configUrlInput.value.trim();
    state.configYaml = configYamlInput.value.trim();
    state.refreshInterval = Math.max(10, parseInt(refreshInput.value, 10) || 30);

    if (state.dataMode === 'api' && !state.token) {
      showError('API mode requires a GitHub token.');
      return;
    }

    let yamlText;
    try {
      btnLoad.disabled = true;
      btnLoad.textContent = 'Loading...';
      yamlText = await resolveConfig();
    } catch (err) {
      showError(err.message);
      btnLoad.disabled = false;
      btnLoad.textContent = 'Load Dashboard';
      return;
    }

    try {
      state.config = parseConfig(yamlText);
    } catch (err) {
      showError('Invalid config: ' + err.message);
      btnLoad.disabled = false;
      btnLoad.textContent = 'Load Dashboard';
      return;
    }

    // Persist
    localStorage.setItem('ghdd-data-mode', state.dataMode);
    localStorage.setItem('ghdd-token', state.token);
    localStorage.setItem('ghdd-config-tab', state.configTab);
    localStorage.setItem('ghdd-config-url', state.configUrl);
    localStorage.setItem('ghdd-config-yaml', state.configTab === 'auto' ? yamlText : state.configYaml);
    localStorage.setItem('ghdd-refresh-interval', String(state.refreshInterval));

    // Always store the resolved yaml for auto-reload
    state.configYaml = yamlText;

    btnLoad.disabled = false;
    btnLoad.textContent = 'Load Dashboard';
    hideError();

    orgName.textContent = state.config.org;
    showDashboard();
    await refresh();
    startAutoRefresh();
  }

  async function refresh() {
    if (!state.config) return;
    state.loading = true;
    state.errors = [];
    renderTable(state.config, state.deployments);

    let results, errors;
    if (state.dataMode === 'static') {
      ({ results, errors } = await fetchAllDeploymentsStatic(state.config));
    } else {
      ({ results, errors } = await fetchAllDeploymentsApi(state.token, state.config));
    }

    state.deployments = results;
    state.loading = false;
    state.errors = errors;

    renderTable(state.config, state.deployments);
    renderSummary(state.config, state.deployments);
    renderErrors(state.errors);

    // Drift details via compare API (only in API mode with a token)
    if (state.dataMode === 'api' && state.token) {
      state.driftDetails = await fetchDriftDetails(state.token, state.config, state.deployments);
      renderTable(state.config, state.deployments);
    }
  }

  function startAutoRefresh() {
    stopAutoRefresh();
    state.countdownSeconds = state.refreshInterval;
    refreshCountdown.textContent = state.countdownSeconds + 's';

    state.refreshTimer = setInterval(function () {
      state.countdownSeconds--;
      if (state.countdownSeconds <= 0) {
        refresh();
        state.countdownSeconds = state.refreshInterval;
      }
      refreshCountdown.textContent = state.countdownSeconds + 's';
    }, 1000);
  }

  function stopAutoRefresh() {
    if (state.refreshTimer) { clearInterval(state.refreshTimer); state.refreshTimer = null; }
    refreshCountdown.textContent = '';
  }

  function showError(msg) { setupError.textContent = msg; setupError.classList.remove('hidden'); }
  function hideError() { setupError.classList.add('hidden'); }

  // ============================================================
  // EVENT LISTENERS
  // ============================================================
  modeStatic.addEventListener('click', function () {
    state.dataMode = 'static';
    updateSetupUI();
  });
  modeApi.addEventListener('click', function () {
    state.dataMode = 'api';
    updateSetupUI();
  });

  tabUrl.addEventListener('click', function () { state.configTab = 'url'; updateSetupUI(); });
  tabPaste.addEventListener('click', function () { state.configTab = 'paste'; updateSetupUI(); });
  tabAuto.addEventListener('click', function () { state.configTab = 'auto'; updateSetupUI(); });

  btnLoad.addEventListener('click', loadConfig);

  btnRefresh.addEventListener('click', function () {
    refresh();
    state.countdownSeconds = state.refreshInterval;
  });

  btnSettings.addEventListener('click', showSetup);

  filterInput.addEventListener('input', function () {
    state.filterText = filterInput.value;
    if (state.config) renderTable(state.config, state.deployments);
  });

  sortSelect.addEventListener('change', function () {
    state.sortMode = sortSelect.value;
    if (state.config) renderTable(state.config, state.deployments);
  });

  // ============================================================
  // INIT
  // ============================================================
  (function init() {
    if (state.configYaml) {
      try {
        state.config = parseConfig(state.configYaml);
        orgName.textContent = state.config.org;
        showDashboard();
        refresh();
        startAutoRefresh();
        return;
      } catch (_) {}
    }
    showSetup();
  })();
})();
</script>
</body>
</html>
